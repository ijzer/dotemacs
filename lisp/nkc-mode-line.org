#+TITLE: Mode Line

Sets up a dynamic mode line that takes into account the width of the
window to shorten and truncate things to display as much as possible
while remaining readable. The mode line is initialized by
[[https://github.com/Malabarba/smart-mode-line][smart-mode-line]] to set up hooks and such and then basically rewritten
wholesale using [[https://github.com/TheBB/spaceline][spaceline]] and individual functions from smart-mode-line.

* Setup
** cl
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (use-package cl-lib))
#+END_SRC
** use-package
#+BEGIN_SRC emacs-lisp

  (require 'use-package)
#+END_SRC
** smart-mode-line
   [[https://github.com/Malabarba/smart-mode-line][github]]
   setting sml/theme to nil limits the colorizing sml adds to the
   modeline, which makes things a bit easier. calling sml/setup adds
   some useful hooks even though we're going to be rewriting a lot of
   the modeline variables sml sets up.
#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line)
#+END_SRC
** spaceline
   [[https://github.com/TheBB/spaceline][github]]
#+BEGIN_SRC emacs-lisp
  (use-package spaceline-segments
    :config
    (when window-system
      (setq spaceline-window-numbers-unicode t)))
#+END_SRC
* Use Spaceline
   Spaceline takes two arguments, things to display on the left-hand
   and right-hand sides of the mode line.
#+BEGIN_SRC emacs-lisp
  (spaceline-install
   <<spaceline-left>>
   <<spaceline-right>>)
#+END_SRC
* Colors
* Segments
** Left
   This blocks out the spaceline segments the left side of the
   mode line will use. Segment definitions can be found by searching
   for spaceline--segment-{name}. 
#+NAME: spaceline-left
#+BEGIN_SRC emacs-lisp
  `((nkc/ace-window
     :face highlight-face
     ,@(when window-system '(:tight)))
    line-column
    ,@(if window-system '(hud :fallback buffer-position) '(buffer-position))
    ((nkc/version-control :fallback nkc/buffer-status)
     (nkc/buffer-id :fallback buffer-id))
    remote-host)
#+END_SRC
** Right 
   This blocks out the spaceline segments the right side of the
   mode line will use. Segment definitions can be found by searching
   for spaceline--segment-{name}.
#+NAME: spaceline-right
#+BEGIN_SRC emacs-lisp
  '((org-clock :when active)
    major-mode
    (minor-modes :when active))
#+END_SRC
** Segment Definitions
   We need to add some segments and to rewrite default segments to
   make things work for me
*** ace window
    Gives the value of the window for selecting with ace-window
#+BEGIN_SRC emacs-lisp
  (spaceline-define-segment nkc/ace-window
    "The current window number for jumping to with ace-window.
  Requires ace-window to be installed and ace-window-display mode to be
  set to true."
    (let* ((win (window-parameter (selected-window) 'ace-window-path)))
      (if spaceline-window-numbers-unicode
	  (spaceline--unicode-number win)
	win))
    :when (bound-and-true-p ace-window-display-mode))
#+END_SRC
*** Modified buffers
#+BEGIN_SRC emacs-lisp
  (defvar nkc/buffer-status-read-only-char "R"
    "Character to display in modeline if buffer is read-only")
  (defvar nkc/buffer-status-not-modified-char ""
    "Character to display in modeline if buffer is not modified")
  (defvar nkc/buffer-status-modified-char "~"
    "Character to display in modeline if buffer is modified")
  (defvar nkc/buffer-status-modified-outside-char "!"
    "Character to display in modeline if buffer was modified outside emacs")

  (spaceline-define-segment nkc/buffer-status
    "Displays a character depending on the status of the buffer."
    (cond
     ((buffer-stale--default-function) nkc/buffer-status-modified-outside-char)
     (buffer-read-only nkc/buffer-status-read-only-char)
     ((buffer-modified-p) nkc/buffer-status-modified-char)
     (t nkc/buffer-status-not-modified-char)))
#+END_SRC
*** Version control
    vc-mode gives us useful info but takes up a ton of space.
    look at [[https://zavoloklom.github.io/material-design-iconic-font/cheatsheet.html][material design iconic font]] for things to display under a
    windowing system. assuming emacs has a way to add fonts with
    propertize, which i'm fairly sure it does.
#+BEGIN_SRC emacs-lisp
  (defvar nkc/vc-state-char-alist
    '((up-to-date . "-")
      (edited . "~")
      (needs-update . "∆")
      (needs-merge . "∇")
      (added . "+")
      (removed . "×")
      (conflict . "!")
      (missing . "?")
      (unregistered . "??")))

  (spaceline-define-segment nkc/version-control
    "Version control information"
    (let* ((mode vc-mode)
	   (backend (vc-backend buffer-file-name))
	   (state (vc-state-refresh buffer-file-name backend)))
      (concat (cdr (assoc state nkc/vc-state-char-alist))
	      (replace-regexp-in-string
	       (format  "\\` \\(%s[-!:?@]\\)" (symbol-name backend)) "" mode)))
    :when (and vc-mode buffer-file-name))
#+END_SRC
*** Buffer ID
**** Helper functions and variables
#+BEGIN_SRC emacs-lisp
  (defvar nkc/buffer-file-replacement-alist
    `((,(rx "[*Org Src " (+ not-newline) "[ " (+ not-newline) "]*]") "")
      (,(rx "/home/" (+? not-newline) "/") "~/")
      (,user-emacs-directory "~emacs/")
      (,(rx "~emacs/lisp/") "~elisp/")
      (,(rx "~/" (+ not-newline) "doc" (+ not-newline) "org") "~org"))
    "AList in the form ((regexp . replacement)) for applying to
  buffer-file-name to shorten it. Replacements are applied sequentially.")

  (defvar nkc/buffer-id-max-width 40 "Max width of buffer id displayed in mode line")

  (defun nkc/replace-buffer-file (buffer-file)
  "Replace matches on buffer-file using nkc/buffer-file-replacement-alist"
    (dolist (prefix nkc/buffer-file-replacement-alist)
      (setq buffer-file (replace-regexp-in-string (car prefix)
						  (cadr prefix)
						  buffer-file)))
    buffer-file)

  (defun nkc/shorten-buffer-file (buffer-file max)
    "Shorten buffer-file to (length max) by replacing directory names with '…'"
    (let* ((folders (split-string buffer-file "/"))
	   (prefix (concat (pop folders) "/")))
      (concat prefix (cl-reduce
		      (apply-partially
		       (lambda (max path segment)
			 (if (not (string-match "…" path))
			     (if (< max (+ (length path) (length segment)))
				 (concat "…/" path)
			       (concat segment "/" path))
			   path))
		       (- max (length prefix) 1))
		      (reverse folders)))))

  (defvar nkc/buffer-file-name nil "File name of current buffer to check for changes")
  (make-variable-buffer-local 'nkc/buffer-file-name)
  (defvar nkc/buffer-id nil "Shortened buffer ID to display in mode line")
  (make-variable-buffer-local 'nkc/buffer-id)

  (defun nkc/update-buffer-id-maybe (buffer-file)
    "Update buffer name for display if buffer-file-name has changed"
    (unless (string= buffer-file nkc/buffer-file-name)
      (setq nkc/buffer-file-name buffer-file)
      (setq nkc/buffer-id (nkc/shorten-buffer-file
			   (nkc/replace-buffer-file buffer-file)
			   nkc/buffer-id-max-width)))
    nkc/buffer-id)
#+END_SRC
**** Segment definition
#+BEGIN_SRC emacs-lisp
  (spaceline-define-segment nkc/buffer-id
    "Current buffer ID"
    (nkc/update-buffer-id-maybe buffer-file-name)
    :when buffer-file-name)
  
#+END_SRC
* Provide
#+BEGIN_SRC emacs-lisp
  (provide 'nkc-mode-line)
#+END_SRC
